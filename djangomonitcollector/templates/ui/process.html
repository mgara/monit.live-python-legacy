{% extends "base.html" %}
{% load staticfiles %}
{% load extra_tags %}


{% block additinal_nav %}
<li><a href="{% url 'monitcollector.views.server' server.id %}"> Server </a></li>
{% endblock %}

<div class="alert alert-info">
	Process {{ process.name }} has status {{ process.status }} with uptime {{ process.uptime|time_str }}
</div>

{% block content %}
{% if process_found %}
<div class="row clearfix">
  <div class="col-md-12 column">
    <div class="col-lg-6 col-md-6 column">
      <div id="graph_cpu" class="graph" style="width:100%;"></div>
    </div>
    <div class="col-lg-6 col-md-6 column">  
      <div id="graph_mem" class="graph" style="width:100%;"></div>
    </div>
      <p class="helper">Zoom: click-drag --- Pan: shift-click-drag --- Restore zoom level: double-click</p>
  </div>
</div>
<div class="row clearfix marginTop">  
  <div class="col-md-12 column">
     {% include "ui/includes/process_table.html" %}
  </div>
</div>
{% else %}
<div class="row clearfix">
  <div class="col-md-12 column">
    <p>Something went wrong. Process not found.</p>
  </div>
</div>
{% endif %}


<script src="{% static 'js/jquery-2.1.4.min.js'%}"></script>
<script src="{% static 'js/dygraph-combined.js'%}"></script>
<script src="{% static 'js/csrf.js'%}"></script>
{% if process.date %}
<script>
    $(document).ready(function () {
        var point_size = 1;
        var stroke_width = 2;
        var draw_point = false;
        var graph_colors = ["#173e43", "#b56969", "#22264b", "#3fb0ac"];

        var update_period = 1000 *{{monit_update_period}};
        var data_cpu = [];
        var dates = {{process.date}};
        var y1 = {{process.cpu_percenttotal}};
        for (i = 0; i < dates.length; i++)
            data_cpu.push([new Date(dates[i] * 1000.), y1[i]]);
        var graph_cpu = new Dygraph(document.getElementById("graph_cpu"), data_cpu,
                {
                    legend: 'always', // show always
                    labelsDivWidth: '140', // default 250
                    labelsSeparateLines: true,
                    ylabel: 'CPU usage (in %)',
                    xlabel: 'Time',
                    drawPoints: draw_point,
                    pointSize: point_size,
                    strokeWidth: stroke_width,
                    labels: ['Time', '{{process.name}} CPU usage'],
                    axisLabelColor: '#CCC',
                    axisLineColor: '#CCC',
                    colors: graph_colors,
                    zoomCallback: function () { // (minDate, maxDate)
                        set_linewidth(graph_cpu, data_cpu);
                    },
                });
        set_linewidth(graph_cpu, data_cpu);
        var data_mem = [];
        y1 = {{process.memory_percenttotal}};
        var y2 = {{process.memory_kilobytetotal}};
        for (i = 0; i < dates.length; i++)
            data_mem.push([new Date(dates[i] * 1000.), y1[i], y2[i] / 1.e6]);
        var graph_mem = new Dygraph(document.getElementById("graph_mem"), data_mem,
                {
                    legend: 'always', // show always
                    labelsDivWidth: '140', // default 250
                    labelsSeparateLines: true,
                    ylabel: 'Memonry usage (in % or GB)',
                    xlabel: 'Time',
                    drawPoints: draw_point,
                    pointSize: point_size,
                    strokeWidth: stroke_width,
                    labels: ['Time', 'memory in %', 'memory in GB'],
                    axisLabelColor: '#CCC',
                    axisLineColor: '#CCC',
                    colors: graph_colors,
                    zoomCallback: function () { // (minDate, maxDate)
                        set_linewidth(graph_mem, data_mem);
                    },
                });
        set_linewidth(graph_mem, data_mem);

        // It sucks that these things aren't objects, and we need to store state in window.
        window.intervalId = setInterval(function () {
            $.post("{% url 'ui:load_process_data' server.id process.name %}", function (data) {
                var date = new Date(JSON.parse(data.date) * 1000.);
                if (date > data_cpu[data_cpu.length - 1][0]) {
                    data_cpu.push([date, JSON.parse(data.cpu_percenttotal)]);
                    graph_cpu.updateOptions({'file': data_cpu});

                    data_mem.push([date, JSON.parse(data.memory_percenttotal), JSON.parse(data.memory_kilobytetotal) / 1.e6]);
                    graph_mem.updateOptions({'file': data_mem});
                }
            });

        }, update_period);
        window.intervalId = setInterval(function () {
            $.post("{% url 'ui:load_process_table' server.id process.name %}", function (data) {
                $("#process_table").replaceWith(data.table_html);
            });
        }, 2000);

        // smaller points if the data array is too big
        function set_linewidth(graph, data) {
            var range = graph.xAxisRange();
            var data_points = 0;
            for (var i = 0; i < data.length; i++) {
                var x = data[i][0];
                //if (x > minDate && x < maxDate)
                if (x > range[0] && x < range[1])
                    data_points++;
            }
            var new_opts = {};
            if (data_points > 2000) {
                new_opts.pointSize = 0.5;
                new_opts.strokeWidth = 0.33;
            }
            else if (data_points > 900) {
                new_opts.pointSize = 1;
                new_opts.strokeWidth = 0.5;
            } else {
                new_opts.pointSize = 1.5;
                new_opts.strokeWidth = 1.;
            }
            graph.updateOptions(new_opts);
        }
    });
</script>
{% csrf_token %}
{% endif %}


{% endblock %}
